<!-- Generated by SpecStory -->

# Fixing 404 error for authentication endpoint (2025-07-03 23:01Z)

_**User**_

@workspace PS C:\Users\aiand\Documents\programming\blog.drewclark.io> try { 
>>     $loginResponse = Invoke-RestMethod -Uri 'http://localhost:3000/api/auth/login' -Method POST -Body (@{ email = 'newuser@example.com'; password = 'password123' } | ConvertTo-Json) -ContentType 'application/json'
>>     $token = $loginResponse.data.token
>>     Invoke-RestMethod -Uri 'http://localhost:3000/api/posts' -Method POST -Body (@{ title = 'Test'; content = 'Test'; published = $true } | ConvertTo-Json) -Headers @{ 'Authorization' = "Bearer $token"; 'Content-Type' = 'application/json' }
>> } catch { 
>>     Write-Host "Error: $($_.Exception.Message)" 
>> }
>> 
Error: Response status code does not indicate success: 404 (Not Found).
PS C:\Users\aiand\Documents\programming\blog.drewclark.io> 
 - help me fix this error

---

_**Assistant**_

The error indicates that the authentication endpoint `/api/auth/login` doesn't exist (404 Not Found). Looking at your codebase, I can see that you only have post routes registered, but no authentication routes.

Here's what's missing and how to fix it:

## 1. Create Authentication Types

First, add authentication types to your `index.ts`:

````typescript
// ...existing code...

// Authentication types
export interface LoginBody {
  email: string;
  password: string;
}

export interface RegisterBody {
  email: string;
  password: string;
  username: string;
  name?: string;
}

export interface AuthResponse {
  user: Omit<User, 'password'>;
  token: string;
}

// ...existing code...
````

## 2. Create Authentication Service

Create `authService.ts`:

````typescript
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { prisma } from '../config/database.js';
import type { LoginBody, RegisterBody, AuthResponse } from '../types/index.js';
import { ValidationError, UnauthorizedError, ConflictError } from '../utils/errors.js';

export class AuthService {
  private readonly JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';
  private readonly JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';

  async register(data: RegisterBody): Promise<AuthResponse> {
    const { email, password, username, name } = data;

    // Validate input
    if (!email || !password || !username) {
      throw new ValidationError('Email, password, and username are required');
    }

    // Check if user already exists
    const existingUser = await prisma.user.findFirst({
      where: {
        OR: [
          { email },
          { username }
        ]
      }
    });

    if (existingUser) {
      throw new ConflictError('User with this email or username already exists');
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 12);

    // Create user
    const user = await prisma.user.create({
      data: {
        email,
        password: hashedPassword,
        username,
        name: name || username,
      },
      select: {
        id: true,
        email: true,
        username: true,
        name: true,
        role: true,
        avatar: true,
        createdAt: true,
        updatedAt: true,
      }
    });

    // Generate token
    const token = this.generateToken(user.id);

    return { user, token };
  }

  async login(data: LoginBody): Promise<AuthResponse> {
    const { email, password } = data;

    if (!email || !password) {
      throw new ValidationError('Email and password are required');
    }

    // Find user
    const user = await prisma.user.findUnique({
      where: { email }
    });

    if (!user) {
      throw new UnauthorizedError('Invalid credentials');
    }

    // Verify password
    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) {
      throw new UnauthorizedError('Invalid credentials');
    }

    // Generate token
    const token = this.generateToken(user.id);

    // Return user without password
    const { password: _, ...userWithoutPassword } = user;

    return { user: userWithoutPassword, token };
  }

  private generateToken(userId: string): string {
    return jwt.sign({ userId }, this.JWT_SECRET, { expiresIn: this.JWT_EXPIRES_IN });
  }

  verifyToken(token: string): { userId: string } {
    try {
      return jwt.verify(token, this.JWT_SECRET) as { userId: string };
    } catch (error) {
      throw new UnauthorizedError('Invalid token');
    }
  }
}
````

## 3. Create Authentication Controller

Create `authController.ts`:

````typescript
import type { FastifyRequest, FastifyReply } from 'fastify';
import { AuthService } from '../services/authService.js';
import { successResponse } from '../utils/errors.js';
import type { LoginBody, RegisterBody } from '../types/index.js';

export class AuthController {
  private authService: AuthService;

  constructor() {
    this.authService = new AuthService();
  }

  async register(request: FastifyRequest, reply: FastifyReply): Promise<void> {
    try {
      const body = request.body as RegisterBody;
      const result = await this.authService.register(body);

      await reply.status(201).send(successResponse(result, 'User registered successfully'));
    } catch (error) {
      throw error;
    }
  }

  async login(request: FastifyRequest, reply: FastifyReply): Promise<void> {
    try {
      const body = request.body as LoginBody;
      const result = await this.authService.login(body);

      await reply.send(successResponse(result, 'Login successful'));
    } catch (error) {
      throw error;
    }
  }
}
````

## 4. Create Authentication Routes

Create `authRoutes.ts`:

````typescript
import type { FastifyInstance } from 'fastify';
import { AuthController } from '../controllers/authController.js';

const authController = new AuthController();

const loginSchema = {
  type: 'object',
  required: ['email', 'password'],
  properties: {
    email: { type: 'string', format: 'email' },
    password: { type: 'string', minLength: 6 },
  },
};

const registerSchema = {
  type: 'object',
  required: ['email', 'password', 'username'],
  properties: {
    email: { type: 'string', format: 'email' },
    password: { type: 'string', minLength: 6 },
    username: { type: 'string', minLength: 3 },
    name: { type: 'string' },
  },
};

export async function authRoutes(fastify: FastifyInstance): Promise<void> {
  fastify.post('/register', {
    schema: {
      body: registerSchema,
    },
  }, authController.register.bind(authController));

  fastify.post('/login', {
    schema: {
      body: loginSchema,
    },
  }, authController.login.bind(authController));
}
````

## 5. Register Auth Routes in Main App

Update `index.ts`:

````typescript
// ...existing code...
import { postRoutes } from './routes/postRoutes.js';
import { authRoutes } from './routes/authRoutes.js';

// ...existing code...

// API routes
fastify.register(async function (fastify) {
  await fastify.register(authRoutes, { prefix: '/api/auth' });
  await fastify.register(postRoutes, { prefix: '/api/posts' });
});

// ...existing code...
````

## 6. Add Missing Environment Variable

Add to your `.env`:

```env
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production
JWT_EXPIRES_IN=7d
```

## 7. Create a Test User

You'll need to create a user first. You can either:

**Option A: Use the register endpoint:**
```powershell
Invoke-RestMethod -Uri 'http://localhost:3000/api/auth/register' -Method POST -Body (@{ email = 'newuser@example.com'; password = 'password123'; username = 'testuser' } | ConvertTo-Json) -ContentType 'application/json'
```

**Option B: Create a seed script in `seed.ts`:**

````typescript
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';

const prisma = new PrismaClient();

async function main() {
  const hashedPassword = await bcrypt.hash('password123', 12);
  
  const user = await prisma.user.upsert({
    where: { email: 'newuser@example.com' },
    update: {},
    create: {
      email: 'newuser@example.com',
      username: 'testuser',
      name: 'Test User',
      password: hashedPassword,
      role: 'ADMIN',
    },
  });

  console.log('Created user:', user);
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
````

Then run: `pnpm --filter backend seed`

After implementing these changes, restart your server and your PowerShell command should work!

---

